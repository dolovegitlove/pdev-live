#!/bin/sh
# =============================================================================
# generate-manifest.sh - Auto-generate TARBALL_MANIFEST.txt from directory contents
# =============================================================================
# Author: PDev Suite
# Version: 1.0.0
# License: MIT
#
# Description:
#   Scans server/, frontend/, client/, installer/ directories and generates
#   a manifest file suitable for tarball validation.
#
# Usage:
#   ./generate-manifest.sh [options]
#
# Options:
#   -o, --output FILE   Output file path (default: TARBALL_MANIFEST.txt)
#   -r, --root DIR      Project root directory (default: parent of script dir)
#   -d, --dry-run       Print to stdout instead of writing file
#   -h, --help          Show this help message
#
# POSIX Compatibility:
#   - Works on macOS (BSD tools) and Linux (GNU tools)
#   - No bash-specific features (grep -oP, arrays, etc.)
#   - Uses portable find/sed syntax
# =============================================================================

# Strict mode - exit on error, undefined vars
set -eu

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="${SCRIPT_DIR%/*}"
OUTPUT_FILE="${SCRIPT_DIR}/TARBALL_MANIFEST.txt"
DRY_RUN=0

# Directories to scan (relative to PROJECT_ROOT)
SCAN_DIRS="server frontend client installer"

# Exclusion patterns (POSIX find -name syntax)
EXCLUDE_PATTERNS="
*.bak
*.backup*
*.log
*.tmp
*.patch
.DS_Store
.env
.env.*
.git
.gitignore
node_modules
logs
archive
dist
bundle
templates
"

# -----------------------------------------------------------------------------
# Functions
# -----------------------------------------------------------------------------

usage() {
    cat << 'EOF'
generate-manifest.sh - Auto-generate TARBALL_MANIFEST.txt from directory contents

Description:
  Scans server/, frontend/, client/, installer/ directories and generates
  a manifest file suitable for tarball validation.

Usage:
  ./generate-manifest.sh [options]

Options:
  -o, --output FILE   Output file path (default: TARBALL_MANIFEST.txt)
  -r, --root DIR      Project root directory (default: parent of script dir)
  -d, --dry-run       Print to stdout instead of writing file
  -h, --help          Show this help message

POSIX Compatibility:
  - Works on macOS (BSD tools) and Linux (GNU tools)
  - No bash-specific features (grep -oP, arrays, etc.)
  - Uses portable find/sed syntax

Examples:
  ./generate-manifest.sh                    # Generate manifest in default location
  ./generate-manifest.sh -d                 # Dry run - print to stdout
  ./generate-manifest.sh -o custom.txt      # Write to custom.txt
  ./generate-manifest.sh -r /path/to/proj   # Use different project root
EOF
    exit 0
}

log_info() {
    printf '[INFO] %s\n' "$1" >&2
}

log_error() {
    printf '[ERROR] %s\n' "$1" >&2
}

die() {
    log_error "$1"
    exit 1
}

# Check if path matches any exclusion pattern
# Args: $1 = file path to check
# Note: SC2254 is intentionally disabled - we WANT glob matching here
is_excluded() {
    _path="$1"
    _basename="${_path##*/}"

    for pattern in $EXCLUDE_PATTERNS; do
        [ -z "$pattern" ] && continue

        # Check basename against pattern (glob matching is intentional)
        # shellcheck disable=SC2254
        case "$_basename" in
            $pattern) return 0 ;;
        esac

        # Check if any path component matches (for directories like node_modules)
        # shellcheck disable=SC2254
        case "$_path" in
            */"$pattern"/*|*/"$pattern"|"$pattern"/*|"$pattern") return 0 ;;
        esac
    done

    return 1
}

# Main manifest generation
generate_manifest() {
    _total=0

    # Header
    cat << 'HEADER'
# PDev Source Tarball Required Files Manifest
# =============================================================================
HEADER
    printf '# Auto-generated by: generate-manifest.sh\n'
    printf '# Generated on: %s\n' "$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
    printf '# Project root: %s\n' "${PROJECT_ROOT}"
    cat << 'HEADER2'
# =============================================================================
#
# Purpose:
#   This manifest defines all files required for a functional PDev Live
#   installation. Used by build scripts and GitHub Actions for validation.
#
# Format:
#   - One file path per line (relative to tarball/project root)
#   - Comments start with #
#   - Sections grouped by directory with file counts
#   - Empty lines separate sections for readability
#
# Excluded patterns:
#   *.bak, *.backup*, *.log, *.tmp, *.patch, .DS_Store,
#   .env*, .git*, node_modules/, logs/, archive/, dist/, bundle/
#
# =============================================================================
HEADER2

    # Root-level config files (special handling)
    if [ -f "${PROJECT_ROOT}/config.js" ]; then
        printf '\n# Root Configuration (1 file - CRITICAL for runtime)\n'
        printf 'config.js\n'
        _total=$((_total + 1))
    fi

    # Process each directory
    for dir in $SCAN_DIRS; do
        _dir_path="${PROJECT_ROOT}/${dir}"

        if [ ! -d "$_dir_path" ]; then
            continue
        fi

        # Collect files for this directory
        _temp_file=$(mktemp)
        _count=0

        find "$_dir_path" -type f 2>/dev/null | sort | while IFS= read -r file; do
            rel_path="${file#"${PROJECT_ROOT}/"}"

            if ! is_excluded "$rel_path"; then
                printf '%s\n' "$rel_path" >> "$_temp_file"
            fi
        done

        # Count files
        if [ -f "$_temp_file" ] && [ -s "$_temp_file" ]; then
            _count=$(wc -l < "$_temp_file" | tr -d ' ')
        fi

        if [ "$_count" -gt 0 ]; then
            # Determine section name
            case "$dir" in
                server)    _section="Server Core" ;;
                frontend)  _section="Frontend Core" ;;
                client)    _section="Client Core" ;;
                installer) _section="Installer Core" ;;
                *)         _section="$dir" ;;
            esac

            printf '\n# %s (%s files)\n' "$_section" "$_count"
            cat "$_temp_file"
            _total=$((_total + _count))
        fi

        rm -f "$_temp_file"
    done

    # Footer with summary
    printf '\n# =============================================================================\n'
    printf '# Total: %s files\n' "$_total"
    printf '# =============================================================================\n'
}

# -----------------------------------------------------------------------------
# Argument Parsing
# -----------------------------------------------------------------------------

while [ $# -gt 0 ]; do
    case "$1" in
        -o|--output)
            [ -z "${2:-}" ] && die "Option $1 requires an argument"
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -r|--root)
            [ -z "${2:-}" ] && die "Option $1 requires an argument"
            PROJECT_ROOT="$2"
            shift 2
            ;;
        -d|--dry-run)
            DRY_RUN=1
            shift
            ;;
        -h|--help)
            usage
            ;;
        -*)
            die "Unknown option: $1"
            ;;
        *)
            die "Unexpected argument: $1"
            ;;
    esac
done

# -----------------------------------------------------------------------------
# Validation
# -----------------------------------------------------------------------------

if [ ! -d "$PROJECT_ROOT" ]; then
    die "Project root does not exist: $PROJECT_ROOT"
fi

# Check at least one scan directory exists
_found_dir=0
for dir in $SCAN_DIRS; do
    if [ -d "${PROJECT_ROOT}/${dir}" ]; then
        _found_dir=1
        break
    fi
done

if [ "$_found_dir" -eq 0 ]; then
    die "No scannable directories found in: $PROJECT_ROOT"
fi

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------

log_info "Generating manifest from: $PROJECT_ROOT"
log_info "Scanning directories: $SCAN_DIRS"

if [ "$DRY_RUN" -eq 1 ]; then
    log_info "Dry run mode - printing to stdout"
    generate_manifest
else
    log_info "Writing to: $OUTPUT_FILE"
    generate_manifest > "$OUTPUT_FILE"
    log_info "Manifest generated successfully"

    # Show summary
    _file_count=$(grep -c '^[^#]' "$OUTPUT_FILE" 2>/dev/null || printf '0')
    log_info "Total files in manifest: $_file_count"
fi

exit 0
